name: Production Deploy with Approval

on:
  workflow_dispatch:
    inputs:
      description:
        description: 'Deployment description'
        required: false
        default: 'Production deployment from staging'

permissions:
  contents: write
  issues: write

env:
  APPROVERS: 'rifqi-thufail,abyansyah052,akhtar2344'
  APPROVAL_TIMEOUT_MINUTES: 60

jobs:
  # Job 1: Buat issue untuk approval dan tunggu
  request-and-wait-approval:
    runs-on: ubuntu-latest
    outputs:
      approved: ${{ steps.wait-approval.outputs.approved }}
      approver: ${{ steps.wait-approval.outputs.approver }}
      issue_number: ${{ steps.create-issue.outputs.issue_number }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create approval request issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          script: |
            const approvers = process.env.APPROVERS.split(',');
            const mentions = approvers.map(a => `@${a}`).join(', ');
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: ` Production Deployment Approval Request - Run #${context.runNumber}`,
              body: `## Production Deployment Request
            
            **Requested by:** @${context.actor}
            **Description:** ${{ github.event.inputs.description }}
            **Workflow Run:** [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            **Time:** ${new Date().toISOString()}
            
            ---
            
            ###  Approvers Required
            ${mentions}
            
            ###  To Approve
            Comment one of: \`approved\`, \`approve\`, \`lgtm\`, \`yes\`
            
            ###  To Deny
            Comment one of: \`deny\`, \`denied\`, \`no\`, \`reject\`
            
            ---
            
             **Timeout:** ${process.env.APPROVAL_TIMEOUT_MINUTES} minutes
            
            The workflow will automatically deploy to production once approved.`,
              labels: ['deployment', 'production', 'awaiting-approval']
            });
            
            console.log(`Created issue #${issue.data.number}`);
            core.setOutput('issue_number', issue.data.number);
            return issue.data.number;

      - name: Wait for approval
        id: wait-approval
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.create-issue.outputs.issue_number }};
            const approvers = process.env.APPROVERS.split(',').map(a => a.trim().toLowerCase());
            const timeoutMs = parseInt(process.env.APPROVAL_TIMEOUT_MINUTES) * 60 * 1000;
            const pollInterval = 15000; // 15 detik
            const startTime = Date.now();
            
            const approveKeywords = ['approved', 'approve', 'lgtm', 'yes'];
            const denyKeywords = ['deny', 'denied', 'no', 'reject'];
            
            console.log(` Waiting for approval on issue #${issueNumber}`);
            console.log(` Authorized approvers: ${approvers.join(', ')}`);
            console.log(` Timeout: ${process.env.APPROVAL_TIMEOUT_MINUTES} minutes`);
            
            let lastCheckedCommentId = 0;
            
            while (true) {
              // Check timeout
              if (Date.now() - startTime > timeoutMs) {
                console.log(' Approval timeout reached');
                
                // Comment timeout pada issue
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: ` **Approval Timeout**\n\nThis deployment request has timed out after ${process.env.APPROVAL_TIMEOUT_MINUTES} minutes without approval.\n\nWorkflow cancelled.`
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  labels: ['deployment', 'production', 'timeout']
                });
                
                core.setOutput('approved', 'false');
                core.setFailed('Deployment approval timeout');
                return;
              }
              
              // Fetch comments
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 100
              });
              
              // Process comments yang belum dicheck
              for (const comment of comments.data) {
                if (comment.id <= lastCheckedCommentId) continue;
                
                const author = comment.user.login.toLowerCase();
                const body = comment.body.toLowerCase().trim();
                
                console.log(` Comment from @${author}: "${comment.body.substring(0, 50)}..."`);
                
                // Check apakah author adalah approver
                if (!approvers.includes(author)) {
                  console.log(` @${author} is not an authorized approver, skipping`);
                  continue;
                }
                
                // Check untuk denial
                if (denyKeywords.some(kw => body.includes(kw))) {
                  console.log(` Deployment DENIED by @${author}`);
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: ` **Deployment Denied**\n\nDenied by @${author}\n\nWorkflow cancelled.`
                  });
                  
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    state: 'closed',
                    labels: ['deployment', 'production', 'denied']
                  });
                  
                  core.setOutput('approved', 'false');
                  core.setFailed(`Deployment denied by ${author}`);
                  return;
                }
                
                // Check untuk approval
                if (approveKeywords.some(kw => body.includes(kw))) {
                  console.log(` Deployment APPROVED by @${author}`);
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: ` **Deployment Approved**\n\nApproved by @${author}\n\nProceeding with production deployment...`
                  });
                  
                  core.setOutput('approved', 'true');
                  core.setOutput('approver', author);
                  return;
                }
                
                lastCheckedCommentId = comment.id;
              }
              
              // Update lastCheckedCommentId
              if (comments.data.length > 0) {
                lastCheckedCommentId = Math.max(lastCheckedCommentId, ...comments.data.map(c => c.id));
              }
              
              const elapsed = Math.floor((Date.now() - startTime) / 1000);
              console.log(` Waiting... (${elapsed}s elapsed, checking every 15s)`);
              
              // Wait before next poll
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

  # Job 2: Deploy ke production HANYA jika approved
  deploy-to-production:
    needs: request-and-wait-approval
    if: needs.request-and-wait-approval.outputs.approved == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout staging branch
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge staging to main
        run: |
          git fetch origin main
          git checkout main
          git merge origin/staging -m "Merge staging to main for production deploy (approved by ${{ needs.request-and-wait-approval.outputs.approver }})"
          git push origin main

      - name: Prepare deployment package
        run: |
          mkdir -p deploy-package
          
          # Copy backend
          cp -r backend deploy-package/
          rm -rf deploy-package/backend/node_modules
          rm -rf deploy-package/backend/tests
          rm -rf deploy-package/backend/.env*
          
          # Copy frontend
          cp -r frontend deploy-package/
          rm -rf deploy-package/frontend/node_modules
          rm -rf deploy-package/frontend/src
          rm -rf deploy-package/frontend/.env*
          
          # Create archive
          cd deploy-package
          zip -r ../production-deploy.zip .
          cd ..
          
          echo " Package created:"
          ls -lh production-deploy.zip

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/prod_key.pem
          chmod 600 ~/.ssh/prod_key.pem
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Deploy to Production EC2
        run: |
          echo " Deploying to Production server..."
          
          # Upload package
          scp -i ~/.ssh/prod_key.pem -o StrictHostKeyChecking=no \
            production-deploy.zip \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/
          
          # Deploy on server
          ssh -i ~/.ssh/prod_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'DEPLOY_SCRIPT'
          
          set -e
          echo " Extracting deployment package..."
          
          # Backup current deployment
          if [ -d /home/ubuntu/app ]; then
            sudo mv /home/ubuntu/app /home/ubuntu/app.backup.$(date +%Y%m%d_%H%M%S) 2>/dev/null || true
          fi
          
          # Extract new deployment
          mkdir -p /home/ubuntu/app
          cd /home/ubuntu/app
          unzip -o /tmp/production-deploy.zip
          rm /tmp/production-deploy.zip
          
          # Install backend dependencies
          echo " Installing backend dependencies..."
          cd /home/ubuntu/app/backend
          npm install --production
          
          # Create uploads directory
          mkdir -p uploads/materials
          chmod 755 uploads uploads/materials
          
          # Restart backend with PM2
          echo " Restarting backend..."
          pm2 delete material-api-prod 2>/dev/null || true
          pm2 start server.js --name material-api-prod \
            --env production \
            -i 1 \
            -- --max-old-space-size=256
          pm2 save
          
          # Build and deploy frontend
          echo "ðŸ—ï¸ Building frontend..."
          cd /home/ubuntu/app/frontend
          npm install
          
          # Set production API URL
          echo "REACT_APP_API_URL=http://${{ secrets.EC2_HOST }}:5001" > .env.production
          npm run build
          
          # Deploy to nginx
          sudo rm -rf /var/www/html/*
          sudo cp -r build/* /var/www/html/
          sudo chown -R www-data:www-data /var/www/html
          
          # Restart nginx
          sudo systemctl restart nginx
          
          echo " Production deployment completed!"
          pm2 status
          
          DEPLOY_SCRIPT

      - name: Health check
        run: |
          echo " Running health checks..."
          sleep 10
          
          # Check backend
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.EC2_HOST }}:5001" || echo "000")
          if [ "$BACKEND_STATUS" = "200" ]; then
            echo " Backend is healthy (HTTP $BACKEND_STATUS)"
          else
            echo " Backend check returned HTTP $BACKEND_STATUS"
          fi
          
          # Check frontend
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.EC2_HOST }}" || echo "000")
          if [ "$FRONTEND_STATUS" = "200" ]; then
            echo " Frontend is healthy (HTTP $FRONTEND_STATUS)"
          else
            echo " Frontend check returned HTTP $FRONTEND_STATUS"
          fi

      - name: Update approval issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ needs.request-and-wait-approval.outputs.issue_number }};
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `##  Production Deployment Successful!
            
            **Deployed at:** ${new Date().toISOString()}
            **Approved by:** @${{ needs.request-and-wait-approval.outputs.approver }}
            
            ###  Production URLs
            - **Frontend:** http://${{ secrets.EC2_HOST }}
            - **Backend API:** http://${{ secrets.EC2_HOST }}:5001
            
            ###  Health Check Results
            Deployment verified and running.`
            });
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              state: 'closed',
              labels: ['deployment', 'production', 'deployed']
            });

  # Job 3: Handle jika tidak di-approve (timeout/denied)
  handle-not-approved:
    needs: request-and-wait-approval
    if: failure() || needs.request-and-wait-approval.outputs.approved != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Log deployment cancelled
        run: |
          echo " Deployment was not approved or was denied/timed out"
          echo "Approval status: ${{ needs.request-and-wait-approval.outputs.approved }}"
